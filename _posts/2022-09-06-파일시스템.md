---
layout: post
title: "[OS] 리눅스 파일 시스템"
subtitle:
categories: OS
tags: ["실습과 그림으로 배우는 리눅스 구조"]
---
    
리눅스에서는 저장 장치 안의 데이터에 접근할 때 일반적으로 직접 저장 장치에 접근하지 않고 **파일시스템을 통해 접근**한다. 0~100GB 저장 장치 중, file.py는 5GB~6GB에 저장해라고 하지 않는다는 것이다. 어디에 어느 정도의 데이터가 있는지 어디가 빈 영역인지를 관리하는 방법이 파일시스템이다. 파일 시스템은 사용자에게 의미 있는 하나의 데이터를 이름, 위치, 사이즈 등의 보조 정보를 추가하여 파일이라는 단위로 관리한다.   
![](https://github.com/aohus/aohus.github.io/blob/main/assets/images/posts/book-linux-7-1.png?raw=true)  

## 리눅스 파일시스템  
파일을 카테고리별로 정리할 수 있도록 리눅스의 파일시스템에는 디렉터리라고 부르는 파일을 보관하는 특수한 파일이 존재한다. 디렉터리 안에는 일반적인 파일 또는 다른 디렉터리를 보관하는 것이 가능하다. 리눅스가 다루는 파일시스템은 여러개이다. 그러나 어떠한 파일시스템이라도 사용자가 다음과 같은 시스템 콜을 호출한다면 통일된 인터페이스로 접근이 가능하다.   

1. 프로세스 -> 시스템 콜  
2. 파일시스템 공통 처리  
3. ext4, XFS, Btrfs 용처리   
4. 디바이스 드라이버에 읽기 처리 의뢰  
5. 장치에서 데이터를 읽음  

## 데이터와 메타데이터  
- 데이터 : 사용자가 작성한 문서나 사진, 동영상, 프로그램 등의 내용  
- 메타데이터 : 파일의 이름이나 저장 장치 내에 위치 사이즈 등의 보조 정보  
	- 종류 : 데이터를 보관하는 일반 파일 / 디렉터리 / 혹은 다른(디바이스?)  
	- 시간 : 작성 시간, 최후 접근 시간, 최후 수정 시간  
	- 권한 : 어느 사용자가 파일에 접근 가능한가  
`df` 로 파일 시스템의 스토리지 사용량 알 수 있지만, 작성한 파일 + 메타 데이터 이므로 주의가 필요하다.   

## 용량 제한  
쿼터(quota) : 파일시스템의 용량을 용도별로 사용할 수 있게 제한하는 기능  
- 사용자 쿼터 : 사용자 별로 용량 제한  
- 디렉토리 쿼터(프로젝트 쿼터): 특정 디렉터리 별로 용량 제한  
- 서브 볼륨 쿼터 : 파일시스템 내의 서브 볼륨이라는 단위별 용량을 제한하는 것으로 거의 디렉터리 쿼터와 사용법은 유사  

## 파일시스템이 깨진 경우  
파일시스템의 데이터를 스토리지에 쓰고 있는 도중에 시스템의 전원이 강제적으로 끊어졌을 때 같은 경우, 파일 시스템의 내용이 깨진다고 한다. 파일시스템이 깨지는 것을 막기 위한 기술으로 저널링과 copy on write 가 있다. 당연히 현존하는 기술로 파일시스템이 깨지는 것을 완전히 막을 수는 없다.   

### 저널링(ext4, XFS)  
파일 시스템 안에 저널 역역이라는 특수한 영역을 준비한다. 파일 시스템을 업데이트 할 때는  
1. 업데이트에 필요한 아토믹한 처리의 목록을 일단 저널 영역에 작성, 이 목록을 저널로그라고 부른다.   
2. 저널 영역의 내용의 바탕으로 실제 파일시스템의 내용을 업데이트한다.   
1 수행 중 깨지면, 실제 데이터에는 문제가 없고 저널 영역부터 다시 쓰면 된다.  
2 수행 중 깨지면 저널 영역 수행을 다시 한다.   

### Copy on Write(Btrfs)  
다른 파일시스템은 일단 파일을 작성하면 그 파일의 배치 장소는 원칙적으로 바뀌지 않는다. 하지만 copy on write 형의 파일시스템은 업데이트를 할 때 다른 장소에 데이터를 쓴다. *(업데이트 된 부분)*   

### 파일시스템의 깨짐에 대한 대책  
일반적으로 파일시스템을 정기적으로 백업하여 파일시스템이 깨진 경우에 마지막에 백업한 시점의 상태로 복원하는 것이 대책이다. 정기적으로 백업을 할 수 없으면 각 파일시스템에 준비된 복구용 명령어를 이용한다. 공통적으로 전재하는 명령어는 'fsck' 인데 다음의 이유로 별로 추천하지는 않는다.   
- 깨지지 않았음을 확인하거나 복구하기 위해 파일시스템 전체를 조사하기 때문에 소요시간이 지나치게 길 수 있다.  
- 오래 걸렸는데 결국 실해하는 경우도 많다.   
- 원하는 상태로 복원한다고 보장할 수 없다.   

## 파일의 종류  
파일의 종류는 아래와 같다.   
- 사용자 데이터를 보관하는 일반파일  
- 파일을 보관하는 디렉터리  
- *디바이스 파일*  
	- 캐릭터 장치  
	- 블록 장치  

리눅스는 스스로 동작하고 있는 하드웨어상의 장치를 거의 모두 파일로서 표현하고 있다. 따라서 리눅스에서는 장치를 파일과 동등하게 open(), read(), write() 등의 시스템 콜을 사용한다.   

### 캐릭터 장치  
읽기와 쓰기가 가능하지만 탐색이 되지 않는다.   
- 터미널, 키보드, 마우스 등이 있다.   

### 블록 장치  
단순히 파일의 읽고 쓰기 이외에 랜덤 접근이 가능하다.  
- HDD, SSD 등의 저장 장치가 있다.   
일반적으로 직접 접근하지 않고 파일 시스템을 경유해서 사용한다. 직접 다루게 되는 경우도 있다.  
- 파티션 테이블의 업데이트   
- 블록 장치 레벨의 데이터 백업과 복구  
- 파일시스템의 작성  
- 파일시스템의 마운트  
- fsck  

## 여러가지 파일 시스템  
exts, XFS, Btrfs -> 저장 장치 상에 존재하는 것. 이외에도 여러 파일 시스템이 있다.   

### 메모리를 기반으로 한 파일시스템  
저장 장치 대신 메모리에 작성하는 'tmpfs' 파일시스템이 있다. 이 파일시스템에 보존한 데이터는 전원을 꺼버리면 사라지지만 저장 장치의 접근이 전혀 발생하지 않아 고속이다. 재부팅 후 남아있을 필요가 없는 `/tmp` 나 `/var/run`에 사용하는 경우가 많다.   
`free` 명령어 출력 결과의 `shared` 필드값이 `tmpfs`에 의해 실제로 사용된 메모리 양을 표시합니다.   

### 네트워크 파일 시스템  
네트워크를 통해 연결된 원격 호스트에 있는 파일에 접근하는 '네트워크 파일 시스템'도 있다.   
![](https://github.com/aohus/aohus.github.io/blob/main/assets/images/posts/book-linux-7-2.png?raw=true)  

### 가상 파일 시스템  
**procfs**  
시스템에 대한 정보를 얻기위한 파일시스템 /proc에 마운트 된다(보통). /proc/$pid/ 이하 하일에 접근함으로써 각 프로세스의 정보를 얻을 수 있다. 지금까지 나왔던 ps, sar, top, free 등 OS 가 제공하는 각종 정보는 procfs로 부터 얻고있다.   

**sysfs**  
procfs에 커널의 프로세스 정보 외 잡다한 정보가 들어가는 것을 막기 위해 생긴 파일시스템 /sys 에 마운트된다.  

**cgroupfs**  
하나의 프로세스 혹은 여러 개의 프로세스로 만들어진 그룹에 대해 여러가지 리소스 사용량의 제한을 가하는 'cgroup' 이라는 기능을 다루는 파일시스템,  /sys/fs/cgroup 이하에 마운트 된다. 보통. CPU, 메모리 등의 사용량을 제한할 수 있다. docker 등의 컨테이너 관리 소프트웨어나 virt-manager 등의 가상 시스템 관리 스프트웨어 등에 각각의 컨테이너나 가상 시스템의 리소스를 제한하기 위해 사용할 수 있다.   

### Btrfs  
**멀티 볼륨**  
**스냅샷**  
**RAID**  
**데이터의 파손 검출, 복구**  
