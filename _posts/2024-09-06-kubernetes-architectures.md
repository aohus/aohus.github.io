---
layout: post
title: "[Kubernetes] 쿠버네티스 구조"
subtitle:
categories: Kubernetes
tags: []
---

## 들어가며
쿠버네티스는 대부분의 리소스를 '오브젝트'라고 불리는 형태로 관리한다. 
쿠버네티스를 소개하는 책 대부분이 쿠버네티스의 주요 오프젝트인 파드, 레플리카셋, 디플로이먼트, 서비스 등을 소개하며 시작한다. 

나는 오브젝트를 생성하고 사용하며 쿠버네티스를 알아보기에 앞서
1) 쿠버네티스가 어떤 구조를 가지고 있고
2) 각 오브젝트의 실체는 무엇이며 
3) 어디에서 생성되어 어떻게 동작하는지
를 알아야 각 기능을 더 빨리 이해하고 기억하는 편이다. 
전체 구조부터 주요 구성요소의 동작을 간단하게 살펴보고 쿠버네티스의 주요 기능을 알아가는 순서로 공부해 보려고한다. 
이번 포스트는 먼저 쿠버네티스의 전체 구조와 핵심 컴포넌트들을 간단하게 살펴보겠다. 

## Kubernetes Architecture Overview  
![2024-09-06-kubernetes-architecture.svg](https://github.com/aohus/aohus.github.io/blob/main/assets/images/posts/2024-09-06-kubernetes-architecture.svg?raw=true) 

쿠버네티스는 **컨트롤 플레인(마스터 노드)**와 **노드**로 구성된다. 각각의 구성 요소는 특정 역할을 담당하며, 전체 클러스터의 안정성과 성능을 보장하기 위해 협력한다.
**컨트롤 플레인**은 클러스터 내 애플리케이션의 배포, 확장, 상태 관리를 포함한 모든 리소스 관리를 책임진다. 여기에는 파드의 스케줄링, 노드 상태 모니터링, 애플리케이션 상태 관리 등이 포함된다. 
**노드**에서는 실제로 컨테이너화된 애플리케이션이 실행된다. 
이러한 구성 요소들은 서로 긴밀하게 협력하며, 안정적인 클러스터 운영을 보장한다. 모든 컴포넌트는 `kube-apiserver`를 통해 상태를 보고하고 명령을 받는다.
  
## 컨트롤 플레인(마스터 노드) 구성 요소   
컨트롤 플레인의 구성 요소는 클러스터에 대한 전역 결정(예: 스케줄링)을 내리고 클러스터 이벤트를 감지 및 응답(예: 디플로이먼트의 레플리카 필드가 충족되지 않을 때 새 파드 시작)한다. 컨트롤 플레인 구성 요소는 클러스터의 모든 머신에서 실행할 수 있다. 그러나 보통은 설정 스크립트는 일반적으로 동일한 머신에서 모든 컨트롤 플레인 구성 요소를 시작하고 이 머신에서 사용자 컨테이너를 실행하지 않는다.  
  
### kube-apiserver   
kube-apiserver는 클러스터 내 모든 작업의 핵심 통로라고 볼 수 있다. 쿠버네티스 API를 제공하고 처리하는 서버이며, 다른 구성 요소나 사용자들이 클러스터와 상호작용할 수 있도록 한다. 예를 들어, 사용자가 파드를 생성하고나 서비스를 배포할 때, 해당 요청은 쿠버네티스 API를 통해 전달되고, 쿠버네티스 API를 통해 클러스터의 상태, 리소스 사용량, 노드 및 파드 상태 등을 조회할 수도 있다. kube-apiserver는 수평적 확장이 가능하도록 설계되어, 여러 개의 인스턴스를 동시에 실행할 수 있으며, 이때 트래픽은 자동으로 여러 인스턴스 간에 부하 분산된다.  
  
### etcd   
모든 클러스터 데이터에 대한 쿠버네티스의 백업 저장소로 사용되는 일관되고 가용성이 높은 키 값 저장소.  
  
### kube-scheduler  
새로 생성된 파드를 감시하고 실행할 노드를 선택하는 컨트롤 플레인 구성 요소. 
스케줄링 결정에 고려되는 요소는 개별 및 집합 리소스 요구 사항, 하드웨어/소프트웨어/정책 제약, 선호도 및 반 선호도 사양, 데이터 로컬리티, 워크로드 간 간섭 및 마감일 등이다.  
  
### kube-controller-manager   
컨트롤러 프로세스를 실행하는 컨트롤 플레인 구성 요소. 컨트롤러 매니저는 쿠버네티스의 전체 상황을 감시하며, 메니페스토의 정의에 맞게 상태를 유지하기 위한 역할을 한다. 
여러 컨트롤러가 각각 자신에게 할당된 오브젝트, 리소스 등으로 감시하며 변화에 반응한다. 컨트롤러는 단일 프로세스에서 별개의 스레드(고루틴)로 실행된다. 자세한 동작은 다음 포스트에서 다루어 보려고한다. 

주요 컨트롤러와 각 컨트롤러의 책임은 아래와 같다. 
- ReplicaSet Controller: ReplicaSet을 모니터링하고 파드 수를 원하는 상태로 유지.  
- Deployment Controller: Deployment 리소스를 관리하여 새로운 ReplicaSet을 생성하거나 업데이트를 수행.  
- StatefulSet Controller: StatefulSet 리소스를 관리하며, 고유한 네트워크 식별자가 필요한 파드를 생성.  
- Job Controller: 일회성 작업을 관리하며, 파드를 생성하여 해당 작업을 완료할 때까지 실행.  
- Node Controller: 노드 상태를 감시하고 노드 장애 시 이를 감지해 대응.  


## 노드 구성 요소
### kubelet   
클러스터의 각 노드에서 실행되는 에이전트. 컨테이너가 파드에서 실행 중인지 확인한다. 
kubelet은 다양한 메커니즘을 통해 제공되는 일련의 파드 스펙을 가져와 해당 파드스펙에 설명된 컨테이너가 실행 중이고 정상 상태인지 확인한다. kubelet은 쿠버네티스에서 생성되지 않은 컨테이너는 관리하지 않는다.   
  
### kube-proxy(Optional)   
kube-proxy는 클러스터의 각 노드에서 실행되는 네트워크 프록시로, 쿠버네티스 서비스 개념의 일부를 구현한다. kube-proxy는 노드에서 네트워크 규칙을 유지 관리한다. 이러한 네트워크 규칙은 클러스터 내부 또는 외부의 네트워크 세션에서 파드로의 네트워크 통신을 허용한다. 운영 체제 패킷 필터링 계층이 있고 사용할 수 있는 경우, kube-proxy는 운영 체제 패킷 필터링 계층을 사용한다. 그렇지 않으면, kube-proxy는 트래픽을 자체적으로 전달한다. 자체적으로 서비스에 대한 패킷 전달을 구현하고 kube-proxy와 동등한 동작을 제공하는 네트워크 플러그인을 사용하는 경우, 클러스터의 노드에서 kube-proxy를 실행할 필요가 없다.   
  
### Container runtime  
쿠버네티스가 컨테이너를 효과적으로 실행하도록 하는 기본 구성 요소이다. 쿠버네티스 환경 내에서 컨테이너의 실행 및 라이프사이클 관리를 담당한다. 쿠버네티스는 컨테이너, CRI-O 및 기타 쿠버네티스 CRI(컨테이너 런타임 인터페이스)의 모든 구현과 같은 컨테이너 런타임을 지원한다.  
  

## Reference    
https://kubernetes.io/docs/concepts/architecture/    